# -*- coding: utf-8 -*-
"""TextClassificationSentimentsPython.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1du5f1XA42gUyvRwGDY9g2G3P1koRj_pg
"""

!pip install transformers

!pip install pandas

!pip install plotly

from transformers import pipeline
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from sklearn.preprocessing import LabelEncoder

# Clasificador de texto
classifier = pipeline(task="text-classification", model="SamLowe/roberta-base-go_emotions", top_k=None)

# Texto a clasificar
sentences = ["I am not having a great day"]

# Ejecutar modelo
model_outputs = classifier(sentences)

result = model_outputs[0]
print(result)

# Crear dataframe con datos de clasificación
df = pd.DataFrame(result)
df

# Obtener el top 5 de acuerdo a las clasificaciones obtenidas
top_5 = df.nlargest(5, 'score')
top_5

# Crear el gráfico de radar
fig = go.Figure()

fig.add_trace(go.Scatterpolar(
    r=top_5['score'].tolist() + [top_5['score'].iloc[0]],
    theta=top_5['label'].tolist() + [top_5['label'].iloc[0]],
    fill='toself',
    name="Top 5 Scores"
))

# Configurar diseño
fig.update_layout(
    polar=dict(
        radialaxis=dict(visible=True, range=[0, max(top_5['score']) + 0.1])
    ),
    title="Top 5 Scores"
)

# Mostrar gráfico
fig.show()

# Texto a clasificar
sentences = [
    "Estoy feliz de verte, aunque me duele el alma que haya tenido que pasar tanto tiempo.",
    "Te quiero más de lo que puedo explicar… pero a veces no entiendo lo que realmente sientes por mí.",
    "Estoy increíblemente orgulloso de todo lo que logré, pero me entristece que no estés aquí para verlo.",
    "Sé que todo saldrá bien, pero no puedo evitar sentir miedo de lo que viene.",
    "Qué lindo volver a este lugar, aunque me trae tantos recuerdos que ya no volverán.",
    "Te quiero con todo mi corazón, pero me enoja que a veces no me escuches.",
    "Me alegra que todo esté bien por ahora, pero no puedo evitar preocuparme por lo que pueda pasar después."
]

data = []

# Ejecutar modelo
for sentence in sentences:
    model_outputs = classifier(sentence)
    data.append({"text": sentence, "label": item["label"], "score": item["score"]} for item in model_outputs[0])

# Aplanar la lista (convertirla en una única lista de diccionarios)
flattened_data = [item for sublist in data for item in sublist]

# Crear dataframe con datos de clasificación
df = pd.DataFrame(flattened_data)
df

# Obtener el Top 5 por cada texto
top_5_per_text = (
    df.drop_duplicates(subset=['text', 'label'])
    .groupby("text", group_keys=False)
    .apply(lambda x: x.nlargest(5, 'score'))
)
top_5_per_text

# Generar un gráfico individual por cada texto
for text in top_5_per_text["text"].unique():
  # Filtrar datos por texto
    df_text = top_5_per_text[top_5_per_text["text"] == text]

    fig = px.bar(
        df_text,
        x="label",
        y="score",
        color="label",
        title=f"Top 5 Scores para: {text}",
        labels={"score": "Score", "label": "Emoción"},
        text_auto=True
    )

    fig.show()

"""# **Perfil de emociones**"""

# Convertir a formato de matriz (pivot table)
df_pivot = top_5_per_text.pivot(index="text", columns="label", values="score").fillna(0)

# Aplicar K-Means
kmeans = KMeans(n_clusters=4, random_state=42, n_init=10)
df_pivot["cluster"] = kmeans.fit_predict(df_pivot)

# Unir los clusters con los textos originales
df_clusters = df_pivot.reset_index()

# Mostrar resultados
print(df_clusters)

# Reducir dimensionalidad con PCA a 3D
pca = PCA(n_components=3)
df_pivot[["PCA1", "PCA2", "PCA3"]] = pca.fit_transform(df_pivot.drop(columns=["cluster"]))

# Convertir a DataFrame para Plotly
df_clusters = df_pivot.reset_index()

# Graficar en 3D
fig = px.scatter_3d(
    df_clusters, x="PCA1", y="PCA2", z="PCA3",
    color=df_clusters["cluster"].astype(str),
    hover_data=["text"], title="Clusters Perfil de Emociones en 3D",
    labels={"cluster": "Cluster", "PCA1": "Componente 1", "PCA2": "Componente 2", "PCA3": "Componente 3"}
)

fig.show()

"""# **Emoción predominante**"""

# Obtener la emoción predominante por cada texto
df_predominante = top_5_per_text.groupby("text", group_keys=False).apply(lambda x: x.nlargest(2, 'score')).reset_index(drop=True)
# Renombrar columnas para claridad
df_predominante = df_predominante.rename(columns={"label": "emoción_predominante", "score": "score_predominante"})

# Convertir emociones en valores numéricos
le = LabelEncoder()
df_predominante["label_encoded"] = le.fit_transform(df_predominante["emoción_predominante"])

# Aplicar K-Means con 3 clusters (ajusta este número si es necesario)
kmeans = KMeans(n_clusters=3, random_state=42, n_init=10)
df_predominante["cluster"] = kmeans.fit_predict(df_predominante[["label_encoded"]])

# Mostrar resultados
print(df_predominante)

# Graficar clusters
fig = px.scatter(
    df_predominante, x="label_encoded", y="score_predominante",
    color=df_predominante["cluster"].astype(str),
    hover_data=["text", "emoción_predominante"],
    title="Clustering de Textos según Emoción Predominante",
    labels={"label_encoded": "Emoción (Codificada)", "score_predominante": "Puntuación Máxima", "cluster": "Cluster"}
)

fig.show()